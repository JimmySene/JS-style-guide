# Simple JS Style Guide

**Comment Ã©crire proprement du code JavaScript ?**

VoilÃ  qui pourrait faire naÃ®tre un dÃ©bat aussi intense qu'el famoso **Pain au chocolat VS Chocolatine** ! ğŸ˜²

J'exagÃ¨re ? Sans doute un peu.

Mais force est de reconnaÃ®tre que certaines rÃ¨gles de style JS semblent plÃ©biscitÃ©es par tous, quand d'autres au contraire semblent parfois se contredire... ğŸ™„

L'idÃ©e de ce guide est de vous inciter Ã  appliquer un style de code JavaScript efficace, simple et rapide Ã  mettre en place. Je l'ai conÃ§u en ayant Ã  l'esprit de toujours garder l'essentiel, tout en enlevant le superflu pour Ã©viter qu'il ne devienne trop complexe. Ainsi, mÃªme les dÃ©butants pourront le comprendre et le mettre en pratique. ğŸ™‚

La plupart de ces recommandations ne sont pas tirÃ©es de mon chapeau (que je ne porte pas), mais des deux mastodontes [Google](https://google.github.io/styleguide/jsguide.html) et [AirBnB](https://github.com/airbnb/javascript/blob/master/README.md) ainsi que du fameux ouvrage *Clean code* de *Robert C.Martin*. Cependant, j'y ai aussi apportÃ© ma petite touche personnelle, ne serait-ce que pour trancher le dÃ©bat quand il le fallait. ğŸ˜‰

Voici le sommaire :

1. [Commentaires](#commentaires)
2. [Nommage](#nommage-des-variables-fonctions)
3. [ChaÃ®nes de caractÃ¨res](#chaines-de-caractÃ¨res)
4. [Blocs de code](#instructions-et-blocs-de-code-fonctions-conditions-boucles)
5. [Variables](#dÃ©claration-des-variables)
6. [Conditions](#conditions)
7. [Boucles](#boucles)
8. [Fonctions](#fonctions)
9. [Tableaux](#tableaux)
10. [Objets](#objets)

## Commentaires

Les commentaires doivent :

- Ãªtre limitÃ©s au profit d'un code auto-suffisant ;
- Ãªtre utiles, clairs et concis ;
- Ãªtre ponctuÃ©s ou non (garder la mÃªme logique dans tout le code) ;
- Ãªtre placÃ©s soit au dessus, soit Ã  droite du code Ã  commenter suivi d'un espace.

Ils peuvent Ãªtre Ã©crits en syntaxe courte `//` (Ã  privilÃ©gier quand c'est possible) ou longue `/* */` :

- en cas de syntaxe courte, mettre un espace aprÃ¨s le `//` ;
- en cas de syntaxe longue, mettre un espace aprÃ¨s le `/*` et avant le `*/`.

```js
// Ceci est une bonne syntaxe de commentaire.
console.log("Syntaxe courte."); // ceci aussi

/* Ceci Ã©galement ! MÃªme si dans ce contexte, on privilÃ©giera la syntaxe courte. */
console.log("Syntaxe multiligne."); /* pareil ici */
uneFonction(unParam /* en revanche lÃ , on ne peut pas faire autrement */, unDeuxiemeParam);
```

En cas de commentaire multiligne, privilÃ©gier la syntaxe longue en faisant commencer chaque nouvelle ligne par une *, situÃ©e juste en dessous de la prÃ©cÃ©dente, suivie d'un espace :

```js
/* 
 * Ceci est encore
 * une bonne syntaxe
 * de commentaire.
 */
console.log("Commentaire multiligne.");

// cependant
// cette syntaxe est Ã©galement possible
// mÃªme si on priviligiera celle du dessus
console.log("Un autre commentaire multiligne.");
```

Utiliser les commentaires [JSDoc](https://jsdoc.app/) pour les dÃ©clarations de fonction, ainsi que des attributs et mÃ©thodes de classe.

## Nommage des variables, fonctions...

Le nommage des diffÃ©rents Ã©lÃ©ments du code doit :

- utiliser une mÃªme langue, idÃ©alement l'anglais (sauf si vous voulez jouer au rebelle patriote) ;
- utiliser le camelCase (variables, propriÃ©tÃ©s, mÃ©thodes) et PascalCase (classes) ;
- Ãªtre clair et concis, il faut Ã©viter les abrÃ©viations ambiguÃ«s et les noms trops longs ;  
- Ãªtre prÃ©fixÃ©s par un *is* ou un *has* si variables ou fonctions boolÃ©ennes ;
- Ãªtre prÃ©fixÃ©s par un verbe d'action si fonctions (get, add, remove, set...).

```js
// anglais, nom correct, camelCase
let goodTitle = "Simple JS Style Guide";
// abrÃ©viation facile Ã  comprendre
let okMsg = "It's ok !";
// prÃ©fix is / has sur les variables boolÃ©ennes
let isMajor = true;
let hasRights = false;

// ici on utilise le verbe "get" pour la fonction de rÃ©cupÃ©ration
function getRules() {
  // rÃ©cupÃ©ration des rÃ¨gles
}
// on le rÃ©utilise ici aussi pour garder une cohÃ©rence
function getBadJokes() {
  // rÃ©cupÃ©ration des blagues nulles
}
```

## ChaÃ®nes de caractÃ¨res

Lorsqu'on Ã©crit une chaine de caractÃ¨re, on doit :

- utiliser les apostrophes ('') ou les guillemets (""), puis s'y tenir dans tout le code ; 
- Ã©viter les Ã©chappements et les concatÃ©nations en utilisant les backticks (``) ;
- lors de l'utilisation des backticks, ne pas mettre d'espaces avant ni aprÃ¨s les accolades.

```js
// guillemets (ma prÃ©fÃ©rence personnelle car il y a beaucoup d'apostrophes dans les phrases en franÃ§ais)
const aGoodString = "Une chaine qui a du caractÃ¨re...";
// apostrophes (on les privilÃ©gie souvent quand on inclus des balises HTML avec attributs qui nÃ©cessitent l'usage des guillemets)
const anotherGoodString = 'Elle est pas mal celle lÃ  !';
// backticks (permet d'Ã©viter l'Ã©chappement des apostrophes / guillemets et la concatÃ©nation due au multiligne ou Ã  l'interpolation de variables / fonctions)
const laughEmoji = "ğŸ¤£";
const hardToSay = `Essaie de prononcer Ã§a correctement : 
"Les chaussettes de l'archiduchesse sont-elles sÃ¨ches ? Archi-sÃ¨ches !" ${laughEmoji}`; // et pas ${ laughEmoji }
```

## Instructions et blocs de code (fonctions, conditions, boucles...)

Voici quelques rÃ¨gles gÃ©nÃ©rales concernant les blocs de code `{}` :

- faire dÃ©buter le bloc de code sur la ligne du mot clÃ© utilisÃ© ;
- Ã©crire son contenu sur une ou plusieurs nouvelles lignes ;
- finir le bloc de code sur une nouvelle ligne ;  
- mettre un espace aprÃ¨s chaque mot clÃ© ;  
- mettre un espace entre `)` et `{` ;
- ne pas mettre d'espace entre les parenthÃ¨ses et leur contenu `(...)` ;  
- mettre une ligne vide en dessous du bloc de code.

Ainsi que leur contenu :

- point-virgule Ã  la fin de chaque instruction ;
- pas d'espace entre l'instruction et le point-virgule ;
- une seule instruction par ligne ;
- indentation de 2 espaces avant chaque instruction situÃ©e dans un bloc.

```js
// Exemple d'un bloc avec crÃ©ation d'une fonction
function superFunction(foo, bar) {
  // les instructions sont sur de nouvelles lignes
  console.log('Une premiÃ¨re instruction !'); // indentation de 2 espaces au dÃ©but
  console.log('Une deuxiÃ¨me instruction !'); // et ; de fin
}

superFunction('machin', 'truc'); // Suite du code en dessous une ligne vide qui le sÃ©pare du prÃ©cÃ©dent bloc

// Exemple d'un bloc de condition
if (age >= 18) {
  console.log('Il est majeur !');
}

// On aurait pu l'Ã©crire sur une ligne car elle ne possÃ¨de qu'une courte instruction
if (age >= 18) console.log('Il est majeur !');
```

## DÃ©claration des variables

Mettre un espace avant et aprÃ¨s :

- les opÃ©rateurs d'affectation `= += -= *= /= %= **=` ;
- les opÃ©rateurs arithmÃ©tiques si il y en a `+ - * / % **`.

**DÃ©clarer et initialiser les variables au bon moment, et pas forcÃ©ment au dÃ©but d'un bloc de code.**

Utiliser les mots clÃ©s *let* ou *const*, pas *var*. L'idÃ©e est d'Ã©viter la crÃ©ation de variables globales.

```js
// utiliser let si la valeur est amenÃ©e Ã  Ãªtre modifiÃ©e
let score = 40;
score += 2;

// utiliser const si la valeur reste fixe
const gameName = 'Super jeu';
```

Lorsqu'on veut dÃ©clarer plusieurs variables il faut rÃ©pÃ©ter le mot clef, ligne par ligne.

```js
// une dÃ©claration par ligne, faire de mÃªme pour les const
let firstVar = 1;
let secondVar = 2;
let thridVar = 3;
```

Grouper toutes les const puis grouper toutes les let.

```js
// les const d'un cÃ´tÃ©
const firstConst = 'Ca changera pas';
const secondConst = 'Ca non plus...';

// les let de l'autre
let firstVar = 'Par contre Ã§a oui';
let secondVar = 'et Ã§a aussi...';
```

Ne pas utiliser le chaÃ®nage d'assignations car cela crÃ©Ã© des variables globales.

```js
// ne pas faire let a = b = c = 'truc'; mais plutÃ´t :
let a = 'truc';
let b = a;
let c = a;
```

## Conditions

Mettre un espace avant et aprÃ¨s les opÃ©rateurs logiques `&& ||` et de comparaison `> < >= <= == != === !==`.

```js
if (machin > truc && untel <= autre)
```

Dans le cas d'une condition if / else, mettre le else au mÃªme niveau que la fin du bloc if.

```js
if (test != null) {
  // ...
} else {
  // ...
}
```

Si il n'y a qu'une courte instruction executÃ©e dans une condition et qu'il n'y a pas de else, on peut choisir d'omettre les `{}` et Ã©crire l'instruction sur une seule ligne.

```js
// exemple d'une condition sur une seule ligne
if (test != null) return true;
```

Dans une fonction, en cas de return dans un if, il est inutile de mettre le else.

```js
const test = "Test validÃ© !";
// si on entre dans le if on sort de la fonction grÃ¢ce au return...
if (test != null) return true;

// ... le code qui suit n'est donc pas lu (sauf si le test est faux bien sÃ»r)
return false;
```

Utiliser la syntaxe raccourcie `if (variable)` si le test porte uniquement sur une valeur boolÃ©enne.

```js
// ici on a une variable boolÃ©enne, donc...
const isMajor = true;
// ... on privilÃ©gie l'utilisation du raccourci au lieu de === true / false
if (isMajor) {
  console.log("Il est majeur !");
}
```

Ne pas utiliser la syntaxe raccourcie si la valeur testÃ©e n'est pas une valeur boolÃ©enne.

```js
// lÃ  par contre on a un nombre et une chaine de caractÃ¨re...
const zero = 0;
const strVide = '';
// mÃªme si on pourrait les tester avec un if(!zero || !strVide) on va plutÃ´t dÃ©tailler
if (zero === 0 || strVide === '') {
  console.log("C'est falsy !");
}
```

Pour tester une Ã©galitÃ© ou une inÃ©galitÃ© il faut utiliser les opÃ©rateurs stricts `===` et `!==`.  
`==` et `!=` ne sont Ã  utiliser qu'en combinaison avec `null` pour tester si une valeur vaut null ou undefined.

```js
// on privilÃ©gie === au == et !== au !=
if (email === "labonneadresseemail@gmail.com") {
  // ...
}

// on vÃ©rifie si email vaut null ou undefined
if (email == null) { // et pas if(!email), voir la rÃ¨gle ci-dessus
  // ...
}
```

En cas d'une condition switch, formater comme suit :

```js
switch (cart) {
  case "Bananes":
    console.log("...");
    break;
  case "Citrons":
    console.log("...");
    break;
  default:
    console.log("...");
}
```

Les ternaires doivent Ãªtre Ã©crites sur une seule ligne et ne doivent pas Ãªtre imbriquÃ©es.

```js
const statut = (age >= 18) ? 'majeur' : 'mineur';
```

Utiliser les syntaxes raccourcies en cas de possibilitÃ©.

```js
// on simule une rÃ©ception de donnÃ©es manquÃ©e
const data = null; 
// on applique 5 Ã  la variable limit au cas oÃ¹ data ne possÃ¨de rien
const limit = data.limit || 5; // pas const limit = data.limit ? data.limit : 5;
```

## Boucles

Nommer ses variables d'incrÃ©ment *i*, *j* ou *k* dans les boucles est OK (c'est une convention).

L'itÃ©rateur dans une boucle for doit Ãªtre dÃ©clarÃ©e avec le mot clef *let*.

```js
for (let i = 0; i < 10; i++) {
  // ...
}
```

Ã‰viter les nombres magiques (nombres qui trainent dans le code sans qu'on sache Ã  quoi ils font rÃ©fÃ©rence).

```js
const numberOfPotatoes = 10;

for (let i = 0; i < numberOfPotatoes; i++) { // pas i < 10
  // ...
}
```

PrivilÃ©gier l'utilisation de la boucle *for of* quand il est possible de l'utiliser, notamment lorsqu'il s'agit de parcourir un tableau.

## Fonctions

Une fonction doit Ãªtre dÃ©clarÃ©e dans un module. Elle peut Ãªtre exportÃ©e ou non. 

**Une fonction doit principalement s'occuper d'une seule tÃ¢che.**  
Si une fonction devient trop lourde, alors il faut la diviser en plusieurs autres fonctions.

Pour dÃ©clarer une fonction, privilÃ©gier la syntaxe flÃ©chÃ©e au mot clÃ© function.

```js
// pas function aGoodFunction { ... }
const aGoodFunction = (str) => {
  // ...
}

```

De mÃªme pour les fonctions de callback.

```js
const truc = array.find((elem) => elem === 'surprise');
```

Il faut Ã©viter de mettre en dur des valeurs en arguments. Il faut d'abord les insÃ©rer dans des variables pour les passer ensuite Ã  la fonction.

```js
const min = 0;
const max = 100;

// pas appelFonction(1, 100);
appelFonction(min, max);
```

Eviter de passer plus de trois arguments Ã  une fonction. PrivilÃ©gier le passage d'un objet de configuration qui contient tout ce qu'il faut.

```js
const options = {
  min: 0,
  max: 100,
  // ...
}
// pas appelFonction(min, max, ...)
appelFonction(options);
```

## Tableaux


Utiliser la syntaxe littÃ©rale pour crÃ©er un tableau sur une ou plusieurs lignes.

```js
// pas new Array(length)

// tableau sur plusieurs lignes
const array = [
  'elem1',
  'elem2', // , sur le dernier Ã©lÃ©ment
  // ...,
];

// tableau sur une seule ligne
const anotherArray = ['elem1', 'elem2', 'elem3'];
```

Utiliser la mÃ©thode *push()* pour insÃ©rer un Ã©lÃ©ment dans un tableau.

```js
const array = [
  'elem1',
  'elem2',
];
// pas array[2] = 'elem3'
array.push('elem3');
```

Pour combiner plusieurs tableaux en un seul, utiliser l'opÃ©rateur spread `...`.  
Pas d'espace avant ni aprÃ¨s l'opÃ©rateur.

```js
const cats = ['chat', 'tigre', 'lion'];
const dogs = ['chien', 'renard', 'loup'];

const animals = [...cats, ...dogs];
```

## Objets

### Objets littÃ©raux

Utiliser la syntaxe littÃ©rale pour crÃ©er un objet sur une ou plusieurs lignes.

```js
// pas new Object()

// objet littÃ©ral sur plusieurs lignes
const obj = { 
  prop: 'valeur',
  prop2: 'valeur', // , sur le dernier Ã©lÃ©ment
  // ...
}

// objet littÃ©ral sur une ligne
const anotherObj = {prop: 'valeur', prop2: 'valeur'}
```

La dÃ©claration des mÃ©thodes doit se faire avec le mot clef *function*.  
Il ne faut pas utiliser la syntaxe flÃ©chÃ©e.

```js
const obj = {
  // pas aMethod: () => { ... }
  aMethod: function() {
    // ...
  }
}
```

Ne pas mettre de contexte inutile dans le nom des mÃ©thodes et des propriÃ©tÃ©s.

```js
// ici on sait qu'on a une pizza, donc...
const pizza = {
  base: 'creme fraiche', // inutile d'Ã©crire pizzaBase...
  ingredients: ['ananas', 'lardons', 'mozza'] // ni pizzaIngredients...
  // ni pizzaToString
  toString: function() {
    // ...
  }
}
```

### POO

Les noms de classes doivent commencer par une majuscule.  
Espace entre le nom de la classe et le dÃ©but du bloc de code.

```js
class Pizza {

}
```
